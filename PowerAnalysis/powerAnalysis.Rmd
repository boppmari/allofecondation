---
title: "Power analysis"
author: "Margaux Jullien"
date: "29 septembre 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r design}
library(lme4)
library(Matrix)
library(MASS)
library(MuMIn)
library(lattice)
library(boot)

setwd("~/DATA/Allofecondation/PowerAnalysis")

# Get the sim.glmm function from github
library(RCurl)
options(RCurlOptions=list(cainfo=system.file("CurlSSL","cacert.pem",package="RCurl")))
eval(expr=parse(text=getURL("https://raw.githubusercontent.com/pcdjohnson/sim.glmm/master/sim.glmm.R")))

design <- read.table("ViabilityPowerAnalysis.csv", header = TRUE, sep = ";", dec = ".")

viabilityData <- sim.glmm(design.data = design,
                          fixed.eff = list(intercept = 1.2383),
                          rand.V = c(IDBox = 0.2912, IDPod = 0.9749, Plant = 0.7432, UniqueGeno = 0.1),
                          distribution = "binomial")

plot(response/n ~ UniqueGeno, ylab = "Viability", data = viabilityData, las = 2)

fit <- glmer(response/n ~ (1|IDBox) + (1|IDPod) + (1|Plant) + (1|UniqueGeno), data = viabilityData, family = "binomial"(link = 'logit'), weights = n, na.action = na.omit)
summary(fit)
fitWithoutGeno <- glmer(response/n ~ (1|IDBox) + (1|IDPod) + (1|Plant), data = viabilityData, family = "binomial"(link = 'logit'), weights = n, na.action = na.omit)
anova(fit, fitWithoutGeno)
AICc(fit, fitWithoutGeno)

## Function to compute the standard error of the parameters
mySumm <- function(.) {
   c(beta=fixef(.), sigma=as.data.frame(VarCorr(.))[,4])
}

set.seed(123)
boo01 <- bootMer(fit, mySumm, nsim = 100)
require("boot")
boo01
head(as.data.frame(boo01))

## intercept
(bCI.1 <- boot.ci(boo01, conf = 0.95, index=1, type=c("norm", "basic", "perc")))

## Residuals variance
(bCI.2 <- boot.ci(boo01, conf = 0.95, index=5, type="norm"))

AICc(fitWithoutGeno) - AICc(fit) > 2

bestlogit <- glmer(propViabilityNA ~ (1|IDBox) + (1|IDPod) + (1|Plant) + (1|Block:Plate), data = box, family = "binomial"(link = 'logit'), weights = NbSeedminusNA, na.action = na.omit)
summary(bestlogit)
```

```{r}
save(bestlogit, file = "modelViability.RData")
load("modelViability.RData")

# Values of genetic variances tested
sigma_geno <- seq(from = 0, to = 1.1, by = 0.05)

simul <- 0.05
for (simul in sigma_geno){
  
  # Simul data
  viabilityData <- sim.glmm(design.data = design,
                            fixed.eff = list(intercept = as.numeric(fixef(bestlogit))),
                            rand.V = c(IDBox = as.data.frame(VarCorr(bestlogit))[1,4], 
                                       IDPod = as.data.frame(VarCorr(bestlogit))[2,4],
                                       Plant = as.data.frame(VarCorr(bestlogit))[3,4], 
                                       UniqueGeno = simul),
                            distribution = "binomial")
  
  # 
  m0 <- glmer(response/n ~ (1|IDBox) + (1|IDPod) + (1|Plant) + (1|UniqueGeno), data = viabilityData, 
               family = "binomial"(link = 'logit'), weights = n, na.action = na.omit)
  
  set.seed(123) # set seed for random number generator to give repeatable results
  boo01 <- bootMer(fit, mySumm, nsim = 100)
}



# Function to simulate viability data
design <- na.omit(design)
sim.viabilityData <- function(infile, varGeno) {
  sim.data <- sim.glmm(design.data = infile,
                       fixed.eff = list(intercept = as.numeric(fixef(bestlogit))),
                       rand.V = c(IDBox = as.data.frame(VarCorr(bestlogit))[1,4], 
                                  IDPod = as.data.frame(VarCorr(bestlogit))[2,4], 
                                  Plant = as.data.frame(VarCorr(bestlogit))[3,4], 
                                  UniqueGeno = varGeno),
                       distribution = "binomial")
  return(sim.data)
}

## Function to compute the standard error of the parameters
mySumm <- function(.) {
  c(beta=fixef(.), sigma=as.data.frame(VarCorr(.))[,4])
}

sim.viability.CI <- function(infile, varGeno, Nboot){
  fit <- glmer(response/n ~ (1|IDBox) + (1|IDPod) + (1|Plant) + (1|UniqueGeno), 
               data = sim.viabilityData(infile, varGeno), 
               family = "binomial"(link = 'logit'), 
               weights = n, na.action = na.omit)

  set.seed(123)
  boo01 <- bootMer(fit, mySumm, nsim = Nboot)
  
  ## intercept
  bCI.1 <- boot.ci(boo01, conf = 0.95, index=1, type="norm")
  CI_intercept <- as.data.frame(bCI.1[4])
  colnames(CI_intercept) <- c("normal.perc", "normal.infIntercept", "normal.supIntercept")
  #return(as.data.frame(bCI.1[4]))
  ## Genetic variance
  bCI.2 <- boot.ci(boo01, conf = 0.95, index=5, type="norm")
  CI_geno <- as.data.frame(bCI.2[4])
  CI_geno[,4] <- varGeno
  colnames(CI_geno) <- c("normal.perc", "normal.infGeno", "normal.supGeno", "varGeno")
  CI <- cbind(CI_intercept, CI_geno[,-1])
  return(CI)
}

# Values of genetic variances tested
sigma_geno <- seq(from = 0, to = 1.1, by = 0.05)
nbBoot <- 5
nbSimul <- 2

CI <- NULL
for (simul in sigma_geno) {
  test <- sapply(1:nbSimul, sim.viability.CI(design, simul, nbBoot))
}

for (simul in sigma_geno) {
  print(simul)
}


CI <- sim.viability.CI(design)
```

```{r}

sim.total <- function(NbSimul, infile, varGeno, NbBoot) {
  CI_geno <- NULL
  for (i in 1:NbSimul) {
    mod.fit <- glmer(response/n ~ (1|IDBox) + (1|IDPod) + (1|Plant) + (1|UniqueGeno),
                     data = sim.viabilityData(infile, varGeno),
                     family = "binomial"(link = "logit"),
                     weights = n, na.action = na.omit)
    est.varGeno <- as.data.frame(VarCorr(mod.fit))[4,4]
    require(boot)
    bootstrap <- bootMer(mod.fit, mySumm, nsim = NbBoot)
    bCI.2 <- boot.ci(bootstrap, conf = 0.95, index=5, type="norm")
    CI.geno.tmp <- as.data.frame(bCI.2[4])
    CI.geno.tmp[,4] <- varGeno
    CI.geno.tmp[,5] <- est.varGeno
    colnames(CI.geno.tmp) <- c("normal.perc", "normal.inf", "normal.sup", "varGeno", "estimated.varGeno")
    
    CI_geno <- rbind(CI_geno, CI.geno.tmp)
  }
  return(CI_geno)
}

NbSimul = 2
NbBoot = 5

CI_simul <- NULL
for (geno in sigma_geno) {
  CI_simul_tmp <- sim.total(NbSimul = NbSimul, infile = design, varGeno = geno, NbBoot = NbBoot)
  CI_simul <- rbind(CI_simul, CI_simul_tmp)
}



```


```{r}
library(lme4)
library(Matrix)
library(MASS)
library(MuMIn)
library(lattice)
library(boot)
# Get the sim.glmm function from github
library(RCurl)
options(RCurlOptions=list(cainfo=system.file("CurlSSL","cacert.pem",package="RCurl")))
eval(expr=parse(text=getURL("https://raw.githubusercontent.com/pcdjohnson/sim.glmm/master/sim.glmm.R")))

load("modelViability.RData")
design <- read.table("ViabilityPowerAnalysis.csv", header = TRUE, sep = ";", dec = ".")
design <- na.omit(design)

sigma_geno <- seq(from = 0, to = 1.1, by = 0.05)


# Function to simulate viability data
sim.viabilityData <- function(infile, varGeno) {
  sim.data <- sim.glmm(design.data = infile,
                       fixed.eff = list(intercept = as.numeric(fixef(bestlogit))),
                       rand.V = c(IDBox = as.data.frame(VarCorr(bestlogit))[1,4], 
                                  IDPod = as.data.frame(VarCorr(bestlogit))[2,4], 
                                  Plant = as.data.frame(VarCorr(bestlogit))[3,4], 
                                  UniqueGeno = varGeno),
                       distribution = "binomial")
  return(sim.data)
}

## Function to compute the standard error of the parameters
mySumm <- function(.) {
  c(beta=fixef(.), sigma=as.data.frame(VarCorr(.))[,4])
}

sim.total <- function(NbSimul, infile, varGeno, NbBoot) {
  
  CI_geno <- NULL
  for (i in 1:NbSimul) {
    
    convergence <- 0
    cat("Simulation number: ", i, "\n", sep = "")
    
    mod.fit <- glmer(response/n ~ (1|IDBox) + (1|IDPod) + (1|Plant) + (1|UniqueGeno),
                     data = sim.viabilityData(infile, varGeno),
                     family = "binomial"(link = "logit"),
                     weights = n, na.action = na.omit)
    
    # Convergence verification
    relgrad <- with(mod.fit@optinfo$derivs,solve(Hessian,gradient))
    if (max(abs(relgrad)) > 0.001){
      cat("max(abs(relgrad)) =", max(abs(relgrad)), "Convergence issue", sep = " ")
      convergence <- convergence + 1
    }
    
    # Get the estimate of the genotypic variance
    est.varGeno <- as.data.frame(VarCorr(mod.fit))[4,4]
    
    # Bootstrap to get confidence intervals of genotypic variance
    require(boot)
    bootstrap <- bootMer(mod.fit, mySumm, nsim = NbBoot)
    bCI.2 <- boot.ci(bootstrap, conf = 0.95, index=5, type="norm")
    CI.geno.tmp <- as.data.frame(bCI.2[4])
    CI.geno.tmp[,4] <- varGeno
    CI.geno.tmp[,5] <- est.varGeno
    colnames(CI.geno.tmp) <- c("normal.perc", "normal.inf", "normal.sup", "varGeno", "estimated.varGeno")
    
    CI_geno <- rbind(CI_geno, CI.geno.tmp)
  }
  return(CI_geno)
  print(convergence)
}

NbSimul = 100
NbBoot = 100

#CI_simul <- NULL
#for (geno in sigma_geno) {
  #set.seed(123)
  #print(geno)
  #CI_simul_tmp <- sim.total(NbSimul = NbSimul, infile = design, varGeno = geno, NbBoot = NbBoot)
  #CI_simul <- rbind(CI_simul, CI_simul_tmp)
#}

#save(CI_simul, file = "CI_simul.RData")

CI_05 <- sim.total(NbSimul = NbSimul, infile = design, varGeno = 0.5, NbBoot = NbBoot)
save(CI_05, file = "CI_05convergence.RData")

```





